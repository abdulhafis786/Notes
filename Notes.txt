Everytime we make a commit, Git creates a commit ID.

Anytime a tag is created, it will take the last commit message.You can also tag a older commit by giving the commit ID.

git push --tags -- will push all the tags in the local repo

To push one tag to the remote repo just give git push origin <tag name> 

while creating tag we give -a for attonated tag and -lw for light weight tag. tag is a read only snapshot of the commit

Branches are read write where you can do anything.

Always have to be in the destination branch where you want to merge.

Even merge will take the last commited messages.When you merge one branch to another , the last commit message made on the source branch will be taken as the commit message

Clean merge will create a automated commit.

git branch -m feature1 ---- to rename a branch. To push it to the remote repository give, git push origin :feat1 feature1. It will automatically get renamed.

git stash save "Message" -- to stash any uncommited files before switching

git stash apply "Stash vaue" -- to apply the stash

git stash drop "Stash id" --- to delete the stash.

git stash clear --- to cleanup all the stashes

git revert "commit ID" --- to revert the changes made earlier. Always try reverting the changes that has been commiting recently but merged commits cannot be reverted

Submodules allow to include other git reporsitory inside your repository.

-----------------------------------------------------------
Vagrant:

Its a simpler way for virtualization and configuration management.

it imports pre-made images called boxes

vagrant init ---- to initialize vagrant.. This will create a vagrant file. Inside this file we have an option called config.vm.box ="base". Edit this to use the default Virtual box.you can also give the image name along with init command.eg:vagrant init ubuntu/trusty46

https://apps.vagrantup.com/boxes -- links for vagrant boxes

vagrant up -- to bring the vagrant machine.

-----------------------------------------------------------

Docker:

OS lever virtualization needs a s set of tools.

1.Virtualization subsystem --docker

2. Cgroup hiererchy -- Control group heirarchy. Set of resorces assigned to a control group.

3.Container mounted into a file system

A [program running into a container has a 

Chroot to restrict the container file system

Cgroup constraints the use of resources and isolates the container from the rest of the system.

Docker is a ligh weight os Virtualization container plaform.

Provides a way to run software in solation

Container acts as jails. No unauthorized access to any one

Docker is a client server architecture..

Client : Runs the docker commands by connecting to the Docker deamon using restful API. Connects using HTTP.

Server: its the docker deamon which manages the Docker container.

Registry: Place where the docker images are stored.

docker stats -- show the statistics of running container

docker pause <conainer name> -- to pause a container.This is mailny used to find out the memeory statistics of the container. Kinda like Freezer on unix control group.

Docker unpause <container name> --- to unpause a container. When you give this, any commands that were given when the container was paused will come back and get displayed on the screen.

docker rm -f <container name> -- to focefully remove the container.

docker commit contanername newimage --- to manually create a image using a base image.You can run this command even after exiting the container.

docker inspect --- to inspect an image created.

Docker file -- file to automate the build process.

FROM: defines a starting image
MAINTAINER : Email address of the builder
SHELL :must be specified in the shell where it needs to be run. For windows it must be "cmd" and in Linux it muxt be "/bin/sh"
eg; SHELL ["/bin/sh", "-c"] for windows it must be "cmd"
Format SHELL["executable","parameters"]

COPY: Copies from source to the building image. The source must be present where the docker file is run

ADD : Copies files even from a remote location. unlike COPY which needs the files to be in local.

RUN: this is to execute the linux commands.

EXPOSE: command to expose a port in docker file.

CMD: This will set the command as the default one for the image so that when an container is created from that image, it will use that as the default command.

Docker build --- command to build a image. -t is given to tag a name to the image.

ssh-keygen -t rsa --- to create a ssh key pair.

docker has a feature of layering when building images. which means it uses the pre build from the cache and reuses it to make it to create a new image.

if you want to push to a local repository then you have to tag the image

eg:docker tag ssh:alpine localhost:5000/ssh:alpine

then we push our image to the registry using push command.

There are three default network that we get when we install docker.

docker network ls -- to list the network.,

User defined network could also be created.if none is specified it would use default as bridge.

bridge network assigns IP address and gateway.
container running in none network could not connect to any network. Its only interface is host

Container using the host netwoek has the same network as the host running.

Container running in bridge can connect to other network and also to other containers. Bridge suppies the /etc/hosts file for each container.

None and host network are not used anymore.

docker create network create <Name> --- to create a new network.default it takes Bridge driver.

docker network inspect bridge --- to inspect the driver bridge and could see which containers are running in the network

To make the userdefined network to be used in our container, give --network in run command

to add a container to another network give,

docker network connect <name> <container name> 

--------------------------------------------------

Chef Continuation:

idempotence -- it means Applying the same action multiple times and the end result does not change.

Convergence -- Chef is a "Desired state configuration"--ie if a resource is applied then no action is taken.

knife node list --- list all the nodes that are bootstraped to the chef server to which the chef repo is configured. One chef repo will get configured for one chef server.

Knife client list -- to list the chef client installed in the nodes

Knife node show <Node name> -- to get the details of the node.

knife node show <Node name> -a fqdn -- to get the fully qualified domain name.

role --- A role is a common grouping of the Runlist that could run on a node. Its like instead of running a run list which contain the recipie, we create a roles which has a set of run lists which could run run on nodes. instead of one run list on each node , a set of run lists on each node.

Environment --- here the code is run as per environment. Recepies is designed as per environment and the entire recepies are run when a particular environment is build.

knife role from file <file name.rb> --to push the roles file to the chef server. Here the roles file are created under the roles folder in Chef repo.The file extension must always be .rb file

knife environment list --- to list the environemt in our chef server.

To create a new environemt createa ruby file in.rb under the environemts directory. If there is no directory, make one

knife environment from file <filename>.rb --- to push the environment file to the chef server.

When u specify the environment, it will apply only the cook book constraint(version) that is given rather than the Version specified in our run list.

-------------------------------------------

PUPPET:

Set up:

Puppet master ---manages multiple nodes
puppet agent --- installed in the nodes which connects to the puppet server

Catalog -- describes the desired state of the computer. It will list all the resources and the dependencies.Puppet uses several source of information to compile the catalog.

Puppet has both client/server architecture and a Solo architecture.

Facter --- its like a command that gathers the facts of the nodes.

Puppet uses R10K utility that connects with the source code to import the IAC code.

Each master and server must need a Valid SSl cert to identify each other.

The puppet agent on the nodes connects to the puppet server every 30 mins to get the catalog and if there is any change from the desired system state and applies the code

Compiling the catalog ---- Master gets the facts from the node and compiles the code to that particular node and sends the catalog to the node to apply it.

by default The puppet server listen on port 8140 and has a default pull architecture or could manually push the configuration to the particular node using Mcollective.

puppet --version -- to check the version of the installed puppet.

For agent the package name is puppet and for master it is puppetmaster.

/etc/puppet/puppet.conf -- configuration file for Puppet which we edit to make the changes to get the agent connected to puppet master. At the main context add 
server=<Master server name>

puppet cert list --all -- To list all the certs. This is given in Master server. The + sign in the front of the name means the cert is signed. The cert must be signed to make connection to the master from the agent.

puppet cert sign --all -- to sign all the certs. To sign only a particular cert just give the name.

puppet agent --enable -- to enable the agent

puppet agent -t -- to refresh the puppet agent on the node.

facter  ---- to get the facts on the node. run on the node

Puppet lanuage defined states. Puppet code is written in manifests under the extension of .pp. 
 Resources -- these are abstracted from the underlying OS and depending on the OS the resources take the necessary providers.

puppet resource user -- to list the user resources.

Puppet resource package -- to list the packages present in the node.



